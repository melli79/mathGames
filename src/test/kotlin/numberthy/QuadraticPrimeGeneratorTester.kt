package numberthy

import common.math.findPrimes
import kotlin.math.max
import kotlin.test.*

class QuadraticPrimeGeneratorTester {
    @Test fun test1_41() {
        var max = 40u;  var maxA = 1;  var maxB = 41
        for (a in 0..10000) {
            for (b in primes.take(3300)) {
                val oldMax = max
                val limit1 = checkLimit(a, b.toInt())
                if (max < limit1) {
                    max = limit1
                    maxA = a;  maxB = b.toInt()
                }
                val limit2 = checkLimit(a, -b.toInt())
                if (max < limit2) {
                    max = limit2
                    maxA = a;  maxB = -b.toInt()
                }
                val limit3 = checkLimit(-a, b.toInt())
                if (max < limit3) {
                    max = limit3
                    maxA = -a;  maxB = b.toInt()
                }
                val limit4 = checkLimit(-a, -b.toInt())
                if (max < limit4) {
                    max = limit4
                    maxA = a;  maxB = -b.toInt()
                }
                if (oldMax < max)
                    println("new maximum $max for n^2 ${maxA}n $maxB")
                else {
                    val limit = max(max(limit1, limit2), max(limit3, limit4))
                    if (limit>20u)
                        println("n^2 ±${a}n ±$b produces primes up to $limit")
                }
            }
        }
        println("The longest sequence of primes is generated by n^2 ${maxA}n +$maxB and of length $max, (a*b=${maxA*maxB}).")
    }
}

private val primes = findPrimes(1001u*1001u).toSet()

fun checkLimit(a :Int, b :Int) = (0..(abs(b).toInt()+1)).first { n -> abs(n*(n +a) +b) !in primes }.toUInt()

fun abs(x :Int) = when {
    x>=0 -> x.toUInt()
    else -> (-x).toUInt()
}
